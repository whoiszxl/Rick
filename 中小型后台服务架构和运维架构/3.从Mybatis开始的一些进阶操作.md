# 从Mybatis开始的一些进阶操作

## Mybatis配置使用
0. 添加pom依赖
```xml
<!-- mybatis配置 -->
<dependency>
	<groupId>org.mybatis.spring.boot</groupId>
	<artifactId>mybatis-spring-boot-starter</artifactId>
	<version>1.3.1</version>
</dependency>
```

1. XML配置
```xml
<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE mapper  
PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"  
"http://mybatis.org/dtd/mybatis-3-mapper.dtd">  
<mapper namespace="com.whoiszxl.dao.UserDao">  
    <!-- 定义缓存  一般是一级缓存，如果用同一个sqlsession 那么相同查询直接会从缓存中查找   
    <cache size="1024" flushInterval="60000" eviction="LRU" readOnly="false"></cache>  
    -->  
    <!-- 查找所有 -->  
    <select id="find" parameterType="Map" resultMap="StudentResult">  
        select * from user  
        <where>  
            <if test="uname!=null and uname!='' ">  
                and uname like #{uname}  
            </if>  
        </where>  
        <if test="start!=null and size!=null">  
            limit #{start},#{size}  
        </if>  
    </select>  
      
    <select id="getTotal" parameterType="Map" resultType="Long">  
        select count(*) from user  
        <where>  
            <if test="uname!=null and uname!='' ">  
                and uname like #{uname}  
            </if>  
        </where>  
    </select>  
    <!-- 按照用户名和密码查找 -->  
    <select id="getUser" resultMap="StudentResult" parameterType="Map">  
        select *from user where uname=#{uname} and upassword=#{upassword}  
    </select>  
    <!-- 删除 -->  
    <delete id="delete" parameterType="Map">  
        delete from user where uid=#{uid}  
    </delete>  
    <!-- 修改 -->  
    <update id="update" parameterType="User">  
        update user  
        <set>  
            <if test="uname!=null">  
                 uname=#{uname},  
            </if>  
            <if test="upassword!=null">  
                upassword=#{upassword},  
            </if>  
            <if test="upower!=null">  
                upower=#{upower},  
            </if>  
        </set>  
        where uid=#{uid}  
    </update>  
    <!-- 增加 -->  
    <insert id="add" parameterType="User">  
        insert into user values(null,#{uname},#{upassword},#{upower})  
    </insert>  
    <resultMap type="User" id="StudentResult">  
        <id property="uid" column="uid"/>  
        <result property="uname" column="uname"/>  
        <result property="upassword" column="upassword"/>  
    </resultMap>  
</mapper>  
```

2. 接口注解方式,使用`@MapperScan("com.whoiszxl.repo")`可以扫描到包中的Mapper
```java
@Mapper
public interface PeopleMapper {

	@Select("SELECT * FROM people WHERE `username` = #{username}")
	People findByUsername(@Param("username") String username);
	
	@Insert("INSERT INTO people(`username`,`address`) VALUES(#{username},#{address})")
	int insert(@Param("username")String username, @Param("address")String address);
	
	@Update("UPDATE people SET `username` = #{username} WHERE `id` = #{id}")
	int updateUsernameById(@Param("id")Long id,@Param("username") String username);
	
	
	//注解配置使用map
	@Insert("insert into people(`username`,`address`) values(#{username,jdbcType=VARCHAR}, #{address,jdbcType=VARCHAR})")
	int insertByMap(Map<String, Object> map);
	
	@Insert("insert into people(username,address) values(#{username},#{address})")
	int insertByEntity(People people);
	
	@Delete("delete from people where id = {#id}")
	int delete(Long id);
}
```

## 集成Redis
0. 添加pom依赖
```xml
<!-- 配置Redis依赖 -->
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

2. 封装常用操作`RedisUtil.java`
3. 操作对象配置,通过将对象序列化存储到Redis中,对象必须实现序列化接口.
```java
@Configuration
public class RedisConfig {
	
	@Bean
	public RedisTemplate<String, Star> redisTemplate(RedisConnectionFactory factory) {
		RedisTemplate<String, Star> template = new RedisTemplate<String, Star>();
		template.setConnectionFactory(factory);
		template.setKeySerializer(new StringRedisSerializer());
		template.setValueSerializer(new RedisObjectSerializer());
		
		return template;
	}
}


/**
 * redis对象序列化
 * @author whoiszxl
 *
 */
public class RedisObjectSerializer implements RedisSerializer<Object>{

	private Converter<Object, byte[]> serializer = new SerializingConverter();
	private Converter<byte[], Object> deserializer = new DeserializingConverter();
	static final byte[] EMPTY_ARRAY = new byte[0];
	
	@Override
	public Object deserialize(byte[] bytes) throws SerializationException {
		if(isEmpty(bytes)) {
			return null;
		}
		try {
			return deserializer.convert(bytes);
		} catch (Exception e) {
			throw new SerializationException("不能反序列",e);
		}
	}

	@Override
	public byte[] serialize(Object object) throws SerializationException {
		if(object == null) {
			return EMPTY_ARRAY;
		}
		try {
			return serializer.convert(object);
		} catch (Exception e) {
			return EMPTY_ARRAY;
		}
	}
	
	private boolean isEmpty(byte[] bytes) {
		return (bytes == null || bytes.length == 0);
	}
}

```

## 集成Mongodb
1. 配置pom依赖
```xml
<!-- 连接mongodb -->
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-data-mongodb</artifactId>
</dependency>
```

2. 给mongodb设置user

```conf
//配置root权限
1. 'mongo' 进入
2. 切换到 'admin' 数据库 use admin
3. 给admin设置用户密码:db.createUser({user: 'root', pwd: '123456', roles: ['root']})
4. 验证是否添加成功，'db.auth(用户名，用户密码)' 这里用db.auth('root', '123456') 如果返回 '1'表示验证成功， 如果是 '0' 表示验证失败...
```

```conf
//给特定的每个库设置权限
1. use Article 切换到特定库
2. db.createUser({user:'whoiszxl',pwd:'111111',roles: [{role:'readWrite',db:'Article'}]})})
3. 连接加密数据库 xxx.db('mongodb://your name: your pwd@ ip :27017/Article');
```

3. //TODO 暂时先跳过


## 使用事务管理数据操作
1. 使用注解指定数据源事务管理:`@Transactional(value="transactionManagerSecondary")`
```java
@Transactional(value="transactionManagerSecondary")//开启事务,指定第二个数据源的事务管理
public int CreateStar(String starname) {
	starRepository.save(new Star(starname));
	
	/*********事务测试*************/
	
	starRepository.save(new Star("事务测试罗事务测试罗事务测试罗事务测试罗事务测试罗事务测试罗事务测试罗事务测试罗事务测试罗事务测试罗"));
	
	/**************************/
	return 1;
}

@Test
public void testTran() throws Exception {
	try {
		starRepositoryService.CreateStar("事务测试");
	} catch (Exception e) {
		//手动回滚,测试的时候没设置这个也实现了回滚..
		TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();
		e.printStackTrace();
	}
}
```

## 使用Springboot实现定时任务
1. 在Springboot入口添加注解`@EnableScheduling //开启定时任务`
2. 配置定时任务的Java配置
```java
/**
 * 定时任务
 * @author whoiszxl
 *
 */
@Component
public class ScheduledTasks {

	
	private static final SimpleDateFormat DATE_FORMAT = new SimpleDateFormat("HH:mm:ss");
	
	@Autowired
	private StarRepositoryService repositoryService;
	
	@Scheduled(fixedRate=3000)
	/**
	 * @Scheduled(fixedRate=3000) :上一次开始执行时间点自后3秒再执行
	 * @Scheduled(fixedDelay=3000) :上一次执行完毕时间点之后3秒再执行
	 * @Scheduled(initialDelay=1000,fixedRate=3000) :第一次延迟1秒执行,之后按上一次开始执行时间点自后3秒再执行
	 */
	//@Scheduled(cron="*/1 * * * * *") linux crontab表达式定义规则
	public void showCurrentTime() {
		System.out.println("时间为:"+DATE_FORMAT.format(new Date()));
		repositoryService.CreateStar("定时");
	}
	
}
```