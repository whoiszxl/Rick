# 认识JVM,Redis进阶操作和Git

## JVM虚拟机结构

![](images/jvm_pro.png)

![](images/jvm_content.png)

## JVM内存机制和参数配置

### 1.加载
1. 通过类的全限定名获取定义此类的二级制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的java.lang.Class对象,作为方法区这个类的各种数据的访问入口


### 2.验证
为了确保class文件的字节流中包含的信息符合当前虚拟机的要求

1. 文件格式验证: 验证字节流是否符合class文件格式的规范
2. 元数据验证: 对字节码描述的信息进行语义分析
3. 字节码验证: 通过数据流和控制流分析,确定程序语义是合法的,符合逻辑的
4. 符号引用验证: 发生在虚拟机将符号引用转化为直接引用的时候

### 3.准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段,主要针对静态变量

### 4.解析
虚拟机将常量池内的符号引用替换为直接引用的过程

### 5.初始化
类初始化阶段是类加载过程中的最后一步,这个才是开始执行类中定义的Java程序代码,在准备阶段,变量已经赋过一次系统要求的初始值,而在初始化阶段,则根据程序员指定的主观计划去初始化类变量和其它资源.


## GC回收

### 垃圾回收算法
1. 引用计数算法: 给对象添加一个引用计数器,每当有一个地方引用它时,计数器的值就+1,当失效的时候,计数器就-1,计数器为0的对象不可以使用,优先被回收.
2. 可达性分析算法: 通过"GC Roots"对象作为起点的引用链,从上往下搜索,一个对象到"GC Roots"没有引用相连,说明不可用.

### 四种对象引用类型
1. 强引用:是使用最普遍的引用：Object o=new Object();  特点：不会被GC
2. 软引用:用来描述一些还有用但是并非必须的对象，在Java中用java.lang.ref.SoftReference类来表示。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。
3. 弱引用:只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象。
4. 虚引用:也称为幻影引用：一个对象是都有虚引用的存在都不会对生存时间都构成影响，也无法通过虚引用来获取对一个对象的真实引用。唯一的用处：能在对象被GC时收到系统通知，JAVA中用PhantomReference来实现虚引用。

对比:
![](images/ref.jpg)


### finalize()方法
对象在被回收之前需要经历两次标记过程,如果发现对象经可达性分析检测,没有引用关联,它将会被标记并且进行筛选,筛选条件是对此对象是否有必要执行finalize方法

### GC收集算法
1. 标记-清除算法: 标记所有需要回收的对象,然后依次全部清除,但是有缺点,一是效率不足,标记和清除两个过程效率不高,二是空间问题会产生很多碎片,对于大对象无法分配内存.
2. 复制算法: 将内存分为大小相等的两块,每次用一块,当一块内存用完,将存活的对象移动到另一块,然后将本块内存全部清除.
3. 标记-整理算法: 让存活的对象向一端移动,然后清理掉边界意外的空间.
4. 分带收集算法: 分为新生代和老年代,新生代对已死对象进行清除,少量存活的对象迁移到老年代,然后老年代才用标记清除算法或者标记整理算法进行清理.


### 垃圾收集器
1. Serial收集器
2. ParNew收集器
3. ParallelScavenge收集器
4. SerialOld收集器
5. ParallelOld收集器
6. CMS收集器


## Redis集群搭建

### 原理介绍

#### Redis集群的数据分片
1. Redis集群没有使用一致性hash,而是引入了哈希槽的概念,Redis集群有16384个哈希槽,每个key通过CRC16校验后对16384取模来决定放置哪个槽.集群的每个节点负责一部分hash槽,举个例子,比如当前集群有3个节点,那么:节点A包含0到5500号哈希槽,节点B包含5501到11000号哈希槽,节点C包含11001到16384号哈希槽.
2. 这种结构很容易添加或者删除节点. 比如如果我想新添加个节点D, 我需要从节点 A, B, C中得部分槽到D上. 如果我像移除节点A,需要将A中得槽移到B和C节点上,然后将没有任何槽的A节点从集群中移除即可. 由于从一个节点将哈希槽移动到另一个节点并不会停止服务,所以无论添加删除或者改变某个节点的哈希槽的数量都不会造成集群不可用的状态.


#### Redis集群的主从复制模型
为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.在我们例子中具有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用.
然而如果在集群创建的时候（或者过一段时间）我们为每个节点添加一个从节点A1，B1，C1,那么整个集群便有三个master节点和三个slave节点组成，这样在节点B失败后，集群便会选举B1为新的主节点继续服务，整个集群便不会因为槽找不到而不可用了
不过当B和B1都失败后，集群是不可用的,所以需要B2了.

#### Redis一致性保证
Redis 并不能保证数据的强一致性. 这意味这在实际中集群在特定的条件下可能会丢失写操作,原因是因为集群是用了异步复制.

### 虚拟机划分
```
主机名	IP	服务端口
默认6379	集群端口
服务端口+10000	主/从
redis-01	172.16.0.41	7111	17111	Master
redis-02	172.16.0.42	7112	17112	Master
redis-03	172.16.0.43	7113	17113	Master
redis-04	172.16.0.44	7114	17114	Slave
redis-05	172.16.0.45	7115	17115	Slave
redis-06	172.16.0.46	7116	17116	Slave
```

### Redis 安装
1. 编译和安装所需的包：`yum install gcc tcl`
2. 下载redis-3.0.3: `wget http://download.redis.io/releases/redis-3.0.3.tar.gz`
3. 创建安装目录：`mkdir /usr/local/redis3`
4. 解压：`tar –zxvf redis-3.0.3.tar.gz && cd redis-3.0.3`
5. 使用PREFIX制定安装目录，并安装`make PREFIX=/usr/local/redis3 install`
6. 安装完成后，可以看到/usr/local/redis3目录下有一个bin目录，bin目录里就是redis的命令,脚本: `redis-benchmark  redis-check-aof  redis-check-dump  redis-cliredis-server`

### 配置redis的conf
```shell
创建conf存放目录
172.16.0.41
#mkdir -p /usr/local/redis3/cluster/7111
# cp /usr/local/src/redis-3.0.3/redis.conf /usr/local/redis3/cluster/7111/redis-7111.conf
172.16.0.42
# mkdir -p /usr/local/redis3/cluster/7112
# cp /usr/local/src/redis-3.0.3/redis.conf /usr/local/redis3/cluster/7112/redis-7112.conf
172.16.0.43
# mkdir -p /usr/local/redis3/cluster/7113
# cp /usr/local/src/redis-3.0.3/redis.conf /usr/local/redis3/cluster/7113/redis-7113.conf
172.16.0.44
# mkdir -p /usr/local/redis3/cluster/7114
# cp /usr/local/src/redis-3.0.3/redis.conf /usr/local/redis3/cluster/7114/redis-7114.conf
172.16.0.45
# mkdir -p /usr/local/redis3/cluster/7115
# cp /usr/local/src/redis-3.0.3/redis.conf /usr/local/redis3/cluster/7115/redis-7115.conf
172.16.0.46
# mkdir -p /usr/local/redis3/cluster/7116
# cp /usr/local/src/redis-3.0.3/redis.conf /usr/local/redis3/cluster/7116/redis-7116.conf
```

### 修改配置选项
1. daemonize	yes	是否作为守护进程运行
2. pidfile	/var/run/redis-7111.pid	如以后台进程运行，则需指定一个pid，默认为/var/run/redis.pid
3. port	7111	监听端口，默认为6379 注意：集群通讯端口值默认为此端口值+10000,如17111
4. databases	1	可用数据库数，默认值为16，默认数据库存储在DB 0号ID库中，无特殊需求，建议仅设置一个数据库databases 1
5. cluster-enabled	yes	打开redis集群
6. cluster-config-file	/usr/local/redis3/cluster/7111/nodes.conf	集群配置文件(启动自动生成)，不用人为干涉
7. cluster-node-timeout	15000	节点互连超时时间。毫秒
8. cluster-migration-barrier	1	数据迁移的副本临界数，这个参数表示的是，一个主节点在拥有多少个好的从节点的时候就要割让一个从节点出来给另一个没有任何从节点的主节点。
9. cluster-require-full-coverage	yes	如果某一些key space没有被集群中任何节点覆盖，集群将停止接受写入。
10. appendonly	yes	启用aof持久化方式,因为redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认值为no

包含了最少选项的集群配置文件示例如下:
```
port 7000
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
```

### 启动六个redis的实例
```shell
172.16.0.41
# /usr/local/redis3/bin/redis-server  /usr/local/redis3/cluster/7111/redis-7111.conf
172.16.0.42
# /usr/local/redis3/bin/redis-server  /usr/local/redis3/cluster/7112/redis-7112.conf
172.16.0.43
# /usr/local/redis3/bin/redis-server  /usr/local/redis3/cluster/7113/redis-7113.conf
172.16.0.44
# /usr/local/redis3/bin/redis-server  /usr/local/redis3/cluster/7114/redis-7114.conf
172.16.0.45
# /usr/local/redis3/bin/redis-server  /usr/local/redis3/cluster/7115/redis-7115.conf
172.16.0.46
# /usr/local/redis3/bin/redis-server  /usr/local/redis3/cluster/7116/redis-7116.conf
```

启动之后用PS命令分别查看实例启动情况: `ps -ef|grep redis`

### 配置集群
1. 安装ruby和rubygems（注意：需要ruby的版本在1.8.7以上）`yum install ruby rubygems`
2. Gem安装redis ruby接口：`gem install redis`
3. 执行redis集群创建命令（只需要在其中一个节点上执行一次即可）:`cd  /usr/local/src/redis-3.0.3/src/ && cp redis-trib.rb /usr/local/bin/redis-trib` , `redis-trib create --replicas 1 172.16.0.44:7114 172.16.0.45:7115 172.16.0.46:7116 172.16.0.41:7111  172.16.0.42:7112 172.16.0.43:7113`

#### 集群创建过程说明
1. 给定redis-trib 程序的命令是create，这表示我们希望创建一个新的集群；
2. 这里的--replicas 1表示每个主节点下有一个从节点；
3. 之后跟着的其它参数则是实例的地址列表，程序使用这些地址所指示的实例来创建新集群；
4. 总的来说，以上命令的意思就是让redis-trib 程序创建一个包含三个主节点和三个从节点的集群。
5. 接着，redis-trib 会打印出一份预想中的配置给你看，如果你觉得没问题的话（注意核对主从关系是否是你想要的），就可以输入yes ，redis-trib 就会将这份配置应用到集群当中。

查看集群状态：`./redis-cli –p 7111 cluster nodes`

### 将redis配置成服务
1. 按上面的操作步骤，Redis的启动脚本为：`/usr/local/src/redis-3.0.3/utils/redis_init_script`将启动脚本复制到/etc/rc.d/init.d/目录下，并命名为redis:` cp /usr/local/src/redis-3.0.3/utils/redis_init_script /etc/rc.d/init.d/redis`

2. 编辑/etc/rc.d/init.d/redis，修改相应配置，使之能注册成为服务：`vi /etc/rc.d/init.d/redis`
    1. 在脚本的第一行后面添加一行内容如下：`#chkconfig: 2345 80 90`,如果不添加上面的内容，在注册服务时会提示：service redis does not support chkconfig
    2. REDISPORT端口修改各节点对应的端口；(注意，端口名将与下面的配置文件名有关)
    3. EXEC=/usr/local/bin/redis-server改为EXEC=/usr/local/redis3/bin/redis-server
    4. CLIEXEC=/usr/local/bin/redis-cli改为CLIEXEC=/usr/local/redis3/bin/redis-cli
    5. 配置文件设置，对CONF属性作如下调整:`CONF="/etc/redis/${REDISPORT}.conf"改为CONF="/usr/local/redis3/cluster/${REDISPORT}/redis-${REDISPORT}.conf"`

3. `chkconfig --add redis`注册为服务
4. 将Redis添加到环境变量中：`vi /etc/profile`,在最后添加以下内容: `export PATH=$PATH:/usr/local/redis3/bin` ,使配置生效:`source /etc/profile`