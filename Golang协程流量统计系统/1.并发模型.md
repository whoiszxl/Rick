# 并发模型

## 早起的并发实现
基于C语言的`fork()`生成子进程,`pid=fork()`,产生一个新进程`pid=0`独自运行,原进程具有一个新的pid继续执行原进程,进程太重了,一般不用了,只用线程

### 伪代码实现
```c++
pid_t pid = fork();

if(pid == 0){
    // do child process
}else if(pid > 0){
    // parent process
}else{
    // fork fail
}

```

## 进程线程协程对比
* 进程:太重了
* 线程:上下文切换开销太大,轮询的时候消耗也大
* 协程:轻量级的线程,简洁的并发模式

## golang协程快速入门

### 实现一个helloworld
协程特性:1. `go`关键字发起一个协程 2. channel协程间通信,通道 3. buffered channels具备缓冲队列的通道

```go
func main() {
	message := make(chan string)
	//go 关键字声明了一个协程,通过messagse的channel将信息传递到print中
	go func() {
		message <- "hello child"
	}()
	fmt.Print("hello man")
	fmt.Print( <-message )
}
```
