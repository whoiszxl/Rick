## 分布式初步认识

### 什么是分布式
1. 任务分解
2. 节点通信

### 分布式和集群区别
1. 分布式：一个业务拆分多个子系统，部署在不同的服务器上
2. 集群：一个业务部署在多个服务器上，高可用

### 解决session跨域共享问题
1. session sticky
2. session replication
3. session 集中存储，存储在db、 存储在缓存服务器 （redis）
4. cookie (主流)，access_token(userid/token/timestamp)，soa架构和微服务架构

## 分布式通信之对象序列化

### java本身的序列化机制存在的问题
1. 序列化数据结果比较大、传输效率比较低
2. 不能跨语言对接

### 发展
1. 先是使用xml格式编码的序列化较多，在很长一段时间内基于XML的SOAP协议及对应WebService框架成为了各个主流开发语言的必备技术。
2. 后来基于JSON的简单文本格式编码的Rest接口取代了XML，但是JSON序列化存储占用空间大，性能低
3. so二进制编码协议出来了，最先诞生的一个开源二进制序列化框架是MessagePack
4. 恰当的序列化协议不仅可以提高系统的通用性、强壮型、安全性、优化性能。同时还能让系统更加易于调试和扩展

### serialVersionUID的作用
文件流中的class和classpath中的class，也就是修改过后的class，不兼容了，处于安全机制考虑，程序抛出了错误，并且拒绝载入。从错误结果来看，如果没有为指定的class配置serialVersionUID，那么java编译器会自动给这个class进行一个摘要算法，类似于指纹算法，只要这个文件有任何改动，得到的UID就会截然不同的，可以保证在这么多类中，这个编号是唯一的。所以，由于没有显指定 serialVersionUID，编译器又为我们生成了一个UID，当然和前面保存在文件中的那个不会一样了，于是就出现了2个序列化版本号不一致的错误。因此，只要我们自己指定了serialVersionUID，就可以在序列化后，去添加一个字段，或者方法，而不会影响到后期的还原，还原后的对象照样可以使用，而且还多了方法或者属性可以用。

### 一些序列化的问题
1. 序列化并不保存静态变量的状态
2. transient关键字表示指定属性不参与序列化
3. 如果父类没有实现序列化，而子类实现列序列化。那么父类中的成员没办法做序列化操作
4. 对同一个对象进行多次写入，打印出的第一次存储结果和第二次存储结果，只多了5个字节的引用关系。并不会导致文件累加

### 总结
1. 在java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化
2. 通过ObjectOutputStream和ObjectInputStream对对象进行序列化合反序列化操作
3. 对象是否允许被反序列化，不仅仅是取决于对象的代码是否一致，同时还有一个重要的因素（UID）
4. 序列化不保存静态变量
5. 要想父类对象也参与序列化操作，那么必须要让父类也实现Serializable接口
6. Transient关键字，主要是控制变量是否能够被序列化。如果没有被序列化的成员变量反序列化后，会被设置成初始值，比如String -> null
7. 通过序列化操作实现深度克隆